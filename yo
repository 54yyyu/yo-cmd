#!/usr/bin/env python3
"""
yo - Convert natural language to terminal commands

A tool that uses Google Gemini API to convert natural language descriptions
into terminal commands. Makes terminal use easier for those unfamiliar with commands.
"""

import os
import sys
import json
import argparse
import readline
import shlex
from pathlib import Path

# Import Google Gemini API client
try:
    from google import genai
except ImportError:
    print("Google Generative AI library not found. Installing...")
    import subprocess
    subprocess.call([sys.executable, "-m", "pip", "install", "google-generativeai"])
    from google import genai

# Define colors for terminal output
class Colors:
    HEADER = '\033[95m'
    BLUE = '\033[94m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    RED = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

# Constants
CONFIG_DIR = os.path.expanduser("~/.config/yo")
CONFIG_FILE = os.path.join(CONFIG_DIR, "config.json")
HISTORY_FILE = os.path.join(CONFIG_DIR, "history.json")
DEFAULT_MODEL = "gemini-2.5-flash-preview-04-17"

def ensure_config_dir():
    """Ensure the config directory exists"""
    if not os.path.exists(CONFIG_DIR):
        os.makedirs(CONFIG_DIR)

def load_config():
    """Load the configuration file"""
    ensure_config_dir()
    if not os.path.exists(CONFIG_FILE):
        return {"api_key": None, "model": DEFAULT_MODEL}
    try:
        with open(CONFIG_FILE, 'r') as f:
            return json.load(f)
    except json.JSONDecodeError:
        return {"api_key": None, "model": DEFAULT_MODEL}

def save_config(config):
    """Save the configuration file"""
    ensure_config_dir()
    with open(CONFIG_FILE, 'w') as f:
        json.dump(config, f)

def load_history():
    """Load command history"""
    ensure_config_dir()
    if not os.path.exists(HISTORY_FILE):
        return []
    try:
        with open(HISTORY_FILE, 'r') as f:
            return json.load(f)
    except json.JSONDecodeError:
        return []

def save_history(history_entry):
    """Save command to history"""
    history = load_history()
    history.append(history_entry)
    # Keep only the last 100 entries
    history = history[-100:]
    ensure_config_dir()
    with open(HISTORY_FILE, 'w') as f:
        json.dump(history, f)

def get_api_key():
    """Get the API key interactively and save it."""
    while True:
        print(f"{Colors.YELLOW}Please enter your Google Gemini API key (or type 'exit' to cancel):{Colors.ENDC}")
        api_key_input = input("> ").strip()
        if not api_key_input:
            print(f"{Colors.RED}API key cannot be empty. Please try again.{Colors.ENDC}")
            continue
        if api_key_input.lower() == 'exit':
            print(f"{Colors.YELLOW}API key configuration cancelled.{Colors.ENDC}")
            return None
        # Basic validation (e.g., length) can be added here if desired
        # For instance: if len(api_key_input) < 20: print("Invalid API key format."); continue
        break

    config = load_config()
    config["api_key"] = api_key_input
    save_config(config)
    print(f"{Colors.GREEN}API key saved successfully!{Colors.ENDC}")
    return api_key_input

def configure_api():
    """Configure the API key. Returns the key if successful, None otherwise."""
    api_key = get_api_key()
    if api_key:
        try:
            genai.configure(api_key=api_key)
            print(f"{Colors.GREEN}Gemini API successfully configured with the new key.{Colors.ENDC}")
            return api_key
        except Exception as e:
            print(f"{Colors.RED}Failed to configure Gemini API with the provided key: {str(e)}{Colors.ENDC}")
            print(f"{Colors.YELLOW}Please ensure your API key is correct and has the necessary permissions.{Colors.ENDC}")
            # Optionally, remove the invalid key from config
            config = load_config()
            config["api_key"] = None
            save_config(config)
            print(f"{Colors.YELLOW}Invalid API key has been cleared from configuration.{Colors.ENDC}")
            return None
    return None

def initialize_genai():
    """Initialize the Gemini API client"""
    config = load_config()
    api_key = config.get("api_key")
    model_name = config.get("model", DEFAULT_MODEL)  # Renamed to model_name for clarity
    
    if not api_key:
        print(f"{Colors.YELLOW}No API key found. Prompting for new key.{Colors.ENDC}")
        api_key = get_api_key() # get_api_key already saves the new key
        if not api_key: # If user still doesn't provide a key
            print(f"{Colors.RED}API key is required to use this tool. Exiting.{Colors.ENDC}")
            sys.exit(1)
    
    try:
        genai.configure(api_key=api_key)
        # Test the API key with a simple call if possible, or rely on first generate_command call
        # For now, we assume configuration is successful if no exception is raised.
        print(f"{Colors.GREEN}Gemini API configured successfully.{Colors.ENDC}")
    except Exception as e:
        print(f"{Colors.RED}Failed to configure Gemini API: {str(e)}{Colors.ENDC}")
        print(f"{Colors.YELLOW}This might be due to an invalid API key or network issues.{Colors.ENDC}")
        # Optionally, prompt to re-enter API key here or handle as a fatal error
        user_choice = input(f"{Colors.YELLOW}Would you like to try updating the API key? (y/n): {Colors.ENDC}").lower()
        if user_choice == 'y':
            api_key = get_api_key()
            if api_key:
                try:
                    genai.configure(api_key=api_key)
                    print(f"{Colors.GREEN}Gemini API configured successfully with new key.{Colors.ENDC}")
                except Exception as e_new:
                    print(f"{Colors.RED}Still failed to configure Gemini API with new key: {str(e_new)}{Colors.ENDC}")
                    # Clear the newly entered (and failed) API key from config
                    config = load_config()
                    if config.get("api_key") == api_key: # api_key here is the newly entered one
                        config["api_key"] = None
                        save_config(config)
                        print(f"{Colors.YELLOW}The newly entered API key also failed and has been cleared from configuration.{Colors.ENDC}")
                    sys.exit(1)
            else:
                print(f"{Colors.RED}No API key provided. Exiting.{Colors.ENDC}")
                sys.exit(1)
        else:
            print(f"{Colors.RED}Exiting due to API configuration failure.{Colors.ENDC}")
            sys.exit(1)
            
    return model_name # Return the model name to be used

def generate_command(description, model_name):
    """Generate a terminal command based on natural language description"""
    config = load_config()
    api_key = config.get("api_key")

    if not api_key:
        print(f"{Colors.RED}API key not configured. Please run 'yo --api' first.{Colors.ENDC}")
        return None

    try:
        # Ensure genai is configured before creating a model instance
        # initialize_genai() should have been called earlier by main logic
        # but as a safeguard, we can check and configure if needed.
        # However, it's better to ensure main() calls initialize_genai() once.
        
        # Create a GenerativeModel instance
        model_instance = genai.GenerativeModel(model_name)
        
        prompt = f"""
Convert the following natural language description into a Unix/Linux terminal command:
"{description}"

Follow these rules:
1. Output ONLY the terminal command, nothing else.
2. Add a comment after the command, starting with '#', that briefly explains what the command does.
3. Format your response exactly like this: command # explanation
4. If the command is interactive (e.g., opens an editor) or would list files/directories, indicate this in the explanation if appropriate.
5. Be precise and concise in your explanation.
6. Do not include any warnings, introductory phrases like "Here is the command:", or additional text outside the command and its explanation.
7. If the request is ambiguous or cannot be translated into a single command, output: ERROR: Ambiguous request or cannot translate.

Examples:
- For "list all files": ls -la # Shows all files (including hidden ones) with details
- For "create a new folder called my_stuff": mkdir my_stuff # Creates a directory named "my_stuff"
- For "find all python files in current directory": find . -name "*.py" # Finds Python files in the current directory
"""

        response = model_instance.generate_content(prompt)
        
        # Accessing the response text safely
        if response and response.candidates and response.candidates[0].content and response.candidates[0].content.parts:
            command_text = response.candidates[0].content.parts[0].text.strip()
            if not command_text or command_text.startswith("ERROR:"):
                print(f"{Colors.YELLOW}Warning: The model could not generate a valid command. Response: {command_text}{Colors.ENDC}")
                return None
            return command_text
        elif hasattr(response, 'text') and response.text: # Fallback for simpler response structures
             command_text = response.text.strip()
             if not command_text or command_text.startswith("ERROR:"):
                print(f"{Colors.YELLOW}Warning: The model could not generate a valid command. Response: {command_text}{Colors.ENDC}")
                return None
             return command_text
        else:
            print(f"{Colors.RED}Error: Received an empty or unexpected response from the API.{Colors.ENDC}")
            # Log the full response for debugging if possible and safe
            # print(f"DEBUG: Full API response: {response}")
            return None
    
    except Exception as e:
        error_message = str(e).lower()
        print(f"{Colors.RED}Error generating command: {str(e)}{Colors.ENDC}")
        if "api key" in error_message or "permission_denied" in error_message or "authentication" in error_message:
            print(f"{Colors.YELLOW}This might be due to an invalid or expired API key.{Colors.ENDC}")
            user_choice = input(f"{Colors.YELLOW}Would you like to update the API key now? (y/n): {Colors.ENDC}").lower()
            if user_choice == 'y':
                new_api_key = get_api_key() # get_api_key saves the key
                if new_api_key:
                    try:
                        genai.configure(api_key=new_api_key) # Re-configure with the new key
                        print(f"{Colors.GREEN}API key updated. Please try your command again.{Colors.ENDC}")
                        # It's better to let the user retry the command rather than re-calling generate_command recursively here
                        return None # Indicate failure for this attempt, user should retry
                    except Exception as e_configure:
                        print(f"{Colors.RED}Failed to configure API with new key: {e_configure}{Colors.ENDC}")
                        return None
                else:
                    return None # No new key provided
            else:
                return None # User chose not to update
        # Handle other specific exceptions if needed
        return None

def show_directory_selector(base_command):
    """Show an interactive directory selector and append chosen path to command."""
    current_dir = os.getcwd()
    original_dir = current_dir
    selected_path = None

    while True:
        print(f"\n{Colors.BOLD}Current directory: {current_dir}{Colors.ENDC}")
        try:
            items = list(os.scandir(current_dir))
        except OSError as e:
            print(f"{Colors.RED}Error accessing directory {current_dir}: {e}{Colors.ENDC}")
            current_dir = original_dir # Reset to original directory on error
            print(f"{Colors.YELLOW}Resetting to starting directory: {current_dir}{Colors.ENDC}")
            continue

        directories = sorted([item for item in items if item.is_dir()], key=lambda x: x.name.lower())
        files = sorted([item for item in items if item.is_file()], key=lambda x: x.name.lower())

        print(f"\n{Colors.BLUE}Directories:{Colors.ENDC}")
        if not directories:
            print("  (No sub-directories)")
        for i, d in enumerate(directories):
            print(f"  {Colors.GREEN}{i+1}.{Colors.ENDC} {d.name}/")

        if files:
            print(f"\n{Colors.BLUE}Files (for reference):{Colors.ENDC}")
            for f in files:
                print(f"     {f.name}")

        print(f"\n{Colors.YELLOW}Options:{Colors.ENDC}")
        print(f"  Enter a number to navigate into a directory.")
        print(f"  Type '{Colors.GREEN}.{Colors.ENDC}' to select the current directory ({Colors.BOLD}{current_dir}{Colors.ENDC}).")
        print(f"  Type '{Colors.GREEN}..{Colors.ENDC}' to go to the parent directory.")
        print(f"  Type '{Colors.GREEN}c{Colors.ENDC}' or '{Colors.GREEN}cancel{Colors.ENDC}' to cancel selection.")
        
        choice = input(f"{Colors.BOLD}Your choice: {Colors.ENDC}").strip().lower()

        if choice == 'c' or choice == 'cancel':
            print(f"{Colors.YELLOW}Directory selection cancelled.{Colors.ENDC}")
            return None # Indicate cancellation
        elif choice == ".":
            selected_path = current_dir
            break
        elif choice == "..":
            parent_dir = str(Path(current_dir).parent)
            if parent_dir == current_dir: # Reached root
                print(f"{Colors.YELLOW}Already at the root directory.{Colors.ENDC}")
            else:
                current_dir = parent_dir
        elif choice.isdigit():
            try:
                dir_index = int(choice) - 1
                if 0 <= dir_index < len(directories):
                    current_dir = os.path.join(current_dir, directories[dir_index].name)
                else:
                    print(f"{Colors.RED}Invalid number. Please choose from the list.{Colors.ENDC}")
            except ValueError:
                print(f"{Colors.RED}Invalid input. Please enter a number, '.', '..', or 'c'.{Colors.ENDC}")
        else:
            print(f"{Colors.RED}Invalid input. Please enter a number, '.', '..', or 'c'.{Colors.ENDC}")

    if selected_path:
        # Ensure the path is quoted if it contains spaces for shell safety
        safe_selected_path = shlex.quote(selected_path)
        # Append the selected path to the base command.
        # This assumes the base_command is ready to have a path appended.
        # More sophisticated logic might be needed if the placeholder is complex.
        if "<PATH>" in base_command:
            final_command = base_command.replace("<PATH>", safe_selected_path)
        else:
            # If no <PATH> placeholder, append to the end. This might need adjustment based on command structure.
            final_command = f"{base_command} {safe_selected_path}"
        print(f"{Colors.GREEN}Selected path: {selected_path}{Colors.ENDC}")
        return final_command
    return None # Should not happen if loop broken correctly

def display_history():
    """Display command history"""
    history = load_history()
    if not history:
        print(f"{Colors.YELLOW}No command history found.{Colors.ENDC}")
        return
    
    print(f"{Colors.HEADER}Command History:{Colors.ENDC}")
    for i, entry in enumerate(history):
        nl_description = entry.get("description", "Unknown command")
        command = entry.get("command", "")
        explanation = entry.get("explanation", "")
        
        print(f"{i+1}. {Colors.BOLD}{nl_description}{Colors.ENDC}")
        print(f"   {Colors.GREEN}{command}{Colors.ENDC} {Colors.BLUE}# {explanation}{Colors.ENDC}")
        print()

def main():
    """Main function to parse arguments and run the tool"""
    parser = argparse.ArgumentParser(
        description="yo - Convert natural language to terminal commands.",
        formatter_class=argparse.RawTextHelpFormatter,
        epilog=f"""
Examples:
  yo list all files in the current directory
  yo create a new folder named 'my_project'
  yo find all python files modified in the last 2 days
  yo --api  # To configure API key and model
  yo --history # To view command history

{Colors.BOLD}Configuration file:{Colors.ENDC} {CONFIG_FILE}
{Colors.BOLD}History file:{Colors.ENDC} {HISTORY_FILE}
"""
    )
    parser.add_argument(
        "description", 
        nargs="*", 
        help="Natural language description of the command to generate. \nExample: 'list all files'"
    )
    parser.add_argument(
        "--api", 
        action="store_true", 
        help="Configure Google Gemini API key and model."
    )
    parser.add_argument(
        "--history", 
        action="store_true", 
        help="Show command history."
    )
    parser.add_argument(
        "--clear-history",
        action="store_true",
        help="Clear all command history."
    )
    parser.add_argument(
        "--model",
        type=str,
        help=f"Temporarily use a specific model for this query (e.g., gemini-1.5-flash-latest). Does not save to config."
    )

    args = parser.parse_args()

    # Initialize API early. initialize_genai handles its own errors and exits if critical.
    # It returns the configured model name from config or default.
    # We pass this to generate_command. If user specifies --model, that overrides.
    default_model_from_config = initialize_genai()
    if not default_model_from_config:
        # This case should ideally be handled by initialize_genai exiting, but as a safeguard:
        print(f"{Colors.RED}Critical error: Gemini API could not be initialized. Exiting.{Colors.ENDC}")
        sys.exit(1)

    # Determine the model to use for this session
    current_session_model = args.model if args.model else default_model_from_config
    if args.model:
        print(f"{Colors.BLUE}Using specified model for this session: {current_session_model}{Colors.ENDC}")

    if args.api:
        print(f"{Colors.BLUE}Current API key: {load_config().get('api_key', 'Not set')}{Colors.ENDC}")
        print(f"{Colors.BLUE}Current Model in config: {load_config().get('model', DEFAULT_MODEL)}{Colors.ENDC}")
        if input(f"{Colors.YELLOW}Do you want to update the API key? (y/n): {Colors.ENDC}").lower() == 'y':
            configure_api() # This will prompt, save, and re-configure genai
        if input(f"{Colors.YELLOW}Do you want to update the default Model in config? (y/n): {Colors.ENDC}").lower() == 'y':
            new_model_config = input(f"{Colors.YELLOW}Enter new default model name (e.g., {DEFAULT_MODEL}): {Colors.ENDC}").strip()
            config = load_config()
            config['model'] = new_model_config if new_model_config else DEFAULT_MODEL
            save_config(config)
            print(f"{Colors.GREEN}Default model updated in config to: {config['model']}{Colors.ENDC}")
        sys.exit(0)

    if args.history:
        display_history()
        sys.exit(0)
    
    if args.clear_history:
        if input(f"{Colors.YELLOW}Are you sure you want to clear all command history? (y/n): {Colors.ENDC}").lower() == 'y':
            if os.path.exists(HISTORY_FILE):
                os.remove(HISTORY_FILE)
                print(f"{Colors.GREEN}Command history cleared.{Colors.ENDC}")
            else:
                print(f"{Colors.YELLOW}No history file found to clear.{Colors.ENDC}")
        else:
            print(f"{Colors.YELLOW}Operation cancelled.{Colors.ENDC}")
        sys.exit(0)

    if not args.description:
        parser.print_help()
        print(f"\n{Colors.YELLOW}Please provide a description of the command you want to generate, or use --api or --history.{Colors.ENDC}")
        sys.exit(1)

    description_text = " ".join(args.description).strip()
    if len(description_text) < 3:
        print(f"{Colors.RED}Description is too short. Please provide a more detailed command.{Colors.ENDC}")
        sys.exit(1)

    print(f"{Colors.BLUE}Generating command for: \"{description_text}\"{Colors.ENDC} (using model: {current_session_model})")
    generated_output = generate_command(description_text, current_session_model)

    if generated_output:
        try:
            parts = generated_output.split('#', 1)
            command = parts[0].strip()
            explanation = parts[1].strip() if len(parts) > 1 else "No explanation provided."
        except Exception: # Broad catch if split fails unexpectedly
            command = generated_output.strip()
            explanation = "Could not parse explanation from API response."
        
        if not command: # If command part is empty after stripping
            print(f"{Colors.RED}The API returned an empty command. Please try rephrasing your request.{Colors.ENDC}")
            sys.exit(1)

        print(f"\n{Colors.GREEN}Suggested command:{Colors.ENDC} {Colors.BOLD}{command}{Colors.ENDC}")
        print(f"{Colors.YELLOW}Explanation:{Colors.ENDC} {explanation}")

        # Path selection logic
        # Standardize placeholders for easier checking
        path_placeholders = ["<PATH>", "<DIRECTORY>", "<FILE>", "[PATH]", "[DIRECTORY]", "[FILE]"]
        needs_path_selection = any(ph in command for ph in path_placeholders)

        if needs_path_selection:
            print(f"\n{Colors.YELLOW}This command seems to require a path/file/directory.{Colors.ENDC}")
            # Create a temporary command string with a standardized placeholder for the selector
            temp_command_for_selector = command
            for ph in path_placeholders:
                temp_command_for_selector = temp_command_for_selector.replace(ph, "<PATH>") # Standardize to <PATH>
            
            path_choice = input(f"{Colors.YELLOW}Do you want to select a path interactively now? (y/n/Enter to skip): {Colors.ENDC}").strip().lower()
            if path_choice == 'y':
                final_command_with_path = show_directory_selector(temp_command_for_selector)
                if final_command_with_path:
                    command = final_command_with_path
                    print(f"\n{Colors.GREEN}Updated command with selected path:{Colors.ENDC} {Colors.BOLD}{command}{Colors.ENDC}")
                else:
                    print(f"{Colors.YELLOW}Path selection cancelled or failed. Command remains: {command}{Colors.ENDC}")
            else:
                 print(f"{Colors.YELLOW}Skipping interactive path selection. Please edit placeholders manually if needed.{Colors.ENDC}")

        # Confirmation before execution
        while True:
            confirm = input(f"\n{Colors.YELLOW}Execute this command? (y/n/e to edit/c to copy): {Colors.ENDC}").strip().lower()
            if confirm in ['y', 'n', 'e', 'c']:
                break
            print(f"{Colors.RED}Invalid choice. Please enter 'y', 'n', 'e', or 'c'.{Colors.ENDC}")

        if confirm == 'y':
            print(f"{Colors.BLUE}Executing: {command}{Colors.ENDC}")
            try:
                exit_code = os.system(command)
                if exit_code == 0:
                    print(f"{Colors.GREEN}Command executed successfully.{Colors.ENDC}")
                else:
                    print(f"{Colors.RED}Command executed with exit code: {exit_code}{Colors.ENDC}")
                save_history({"description": description_text, "command": command, "explanation": explanation, "executed_successfully": exit_code == 0})
            except Exception as e:
                print(f"{Colors.RED}Error executing command: {str(e)}{Colors.ENDC}")
        elif confirm == 'e':
            print(f"{Colors.YELLOW}Current command: {Colors.BOLD}{command}{Colors.ENDC}")
            # Set up readline to pre-fill the command for the input prompt
            readline.set_startup_hook(lambda: readline.insert_text(command))
            try:
                # The input prompt will show the 'command' pre-filled, allowing the user to edit it.
                edited_command_input = input(f"{Colors.YELLOW}Edit command (Press Enter to use current, or modify):\n{Colors.BOLD}> {Colors.ENDC}")
            finally:
                readline.set_startup_hook(None) # Important to clear the hook

            final_edited_command = edited_command_input.strip() # Strip whitespace

            if not final_edited_command: # If user cleared the input and pressed Enter
                print(f"{Colors.YELLOW}Edit cancelled or empty command entered. Using original command: {command}{Colors.ENDC}")
                final_edited_command = command # Fallback to original
            
            print(f"{Colors.BLUE}Executing edited command: {final_edited_command}{Colors.ENDC}")
            try:
                exit_code = os.system(final_edited_command)
                if exit_code == 0:
                    print(f"{Colors.GREEN}Command executed successfully.{Colors.ENDC}")
                else:
                    print(f"{Colors.RED}Command executed with exit code: {exit_code}{Colors.ENDC}")
                save_history({"description": description_text, "command": final_edited_command, "explanation": explanation, "executed_successfully": exit_code == 0})
            except Exception as e:
                print(f"{Colors.RED}Error executing edited command: {str(e)}{Colors.ENDC}")
        elif confirm == 'c':
            try:
                import pyperclip
                pyperclip.copy(command)
                print(f"{Colors.GREEN}Command copied to clipboard!{Colors.ENDC}")
                # Optionally, save to history even if only copied
                save_history({"description": description_text, "command": command, "explanation": explanation, "executed_successfully": 'copied'})
            except ImportError:
                print(f"{Colors.RED}pyperclip library not found. Cannot copy to clipboard.{Colors.ENDC}")
                print(f"{Colors.YELLOW}To enable copying, please install it: pip install pyperclip{Colors.ENDC}")
            except pyperclip.PyperclipException as e:
                print(f"{Colors.RED}Could not copy to clipboard: {e}{Colors.ENDC}")
                print(f"{Colors.YELLOW}You might need to install a copy/paste mechanism like xclip or xsel on Linux.{Colors.ENDC}")
        else: # 'n'
            print(f"{Colors.YELLOW}Command execution cancelled.{Colors.ENDC}")
    else:
        print(f"{Colors.RED}Could not generate a command. Please try rephrasing your request, check your API key, or try a different model.{Colors.ENDC}")

if __name__ == "__main__":
    main()
